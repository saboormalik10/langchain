/**
 * SQL Utility Functions for cleaning, validating, and fixing SQL queries
 */

// Function to fix malformed SQL structures commonly generated by SQL Agent
export function fixMalformedSQLStructures(sql: string): string {
    if (!sql) return '';

    let fixedSQL = sql;

    // Fix 1: Handle malformed CTE/Subquery structure ") SELECT" pattern
    // Example: "FROM table ) SELECT ..." -> Convert to proper CTE or remove extra parenthesis
    if (fixedSQL.match(/\)\s*SELECT/i)) {
        console.log('ðŸ”§ Detected ") SELECT" pattern - fixing malformed CTE structure');

        // Try to identify if this should be a CTE
        const cteMatch = fixedSQL.match(/(.*?)\s*\)\s*SELECT(.*)/i);
        if (cteMatch) {
            const [, beforePart, afterPart] = cteMatch;

            // Check if the before part looks like a valid subquery
            if (beforePart.match(/SELECT.*FROM/i)) {
                // Convert to CTE structure
                fixedSQL = `WITH temp_cte AS (${beforePart.trim()}) SELECT${afterPart}`;
                console.log('ðŸ”§ Converted malformed structure to CTE');
            } else {
                // Remove the orphaned parenthesis
                fixedSQL = fixedSQL.replace(/\)\s*SELECT/i, ' SELECT');
                console.log('ðŸ”§ Removed orphaned parenthesis before SELECT');
            }
        }
    }

    // Fix 2: Handle multiple SELECT statements - keep only the first complete one
    const selectMatches = [...fixedSQL.matchAll(/SELECT\s+[\s\S]*?FROM[\s\S]*?(?=\s+SELECT|\s*$)/gi)];
    if (selectMatches.length > 1) {
        console.log(`ðŸ”§ Found ${selectMatches.length} SELECT statements - using the first complete one`);
        fixedSQL = selectMatches[0][0].trim();
    }

    // Fix 3: Remove trailing explanatory text that's not SQL
    fixedSQL = fixedSQL.replace(/This query returns.*$/i, '');
    fixedSQL = fixedSQL.replace(/All patients in the result set.*$/i, '');
    fixedSQL = fixedSQL.replace(/If you need additional.*$/i, '');

    // Fix 4: Clean up extra semicolons and whitespace
    fixedSQL = fixedSQL.replace(/;+\s*$/, '').trim();

    // Fix 5: Validate basic SQL structure
    if (!fixedSQL.match(/SELECT\s+.*\s+FROM\s+/i)) {
        console.log('ðŸ”§ Warning: SQL does not have basic SELECT...FROM structure');
        return '';
    }

    // Fix 6: Handle non-existent table references
    // This should be handled by table validation, but we can add basic cleanup
    fixedSQL = fixedSQL.replace(/JOIN\s+risk_scores\s+/gi, '-- JOIN risk_scores '); // Comment out non-existent table

    return fixedSQL;
}

export function cleanSQLQuery(input: string): string {
    if (!input || typeof input !== 'string') return '';

    let sql = '';

    // First try to extract from code blocks
    const codeBlockMatch = input.match(/```(?:sql)?\s*((?:SELECT|select)[\s\S]*?)```/);
    if (codeBlockMatch) {
        sql = codeBlockMatch[1].trim();
    } else {
        const inlineCodeMatch = input.match(/`((?:SELECT|select)[\s\S]*?)`/);
        if (inlineCodeMatch) {
            sql = inlineCodeMatch[1].trim();
        } else {
            // More comprehensive regex that captures multi-line SQL including JOINs
            const sqlMatch = input.match(/(SELECT\s+[\s\S]*?\s+FROM\s+[\s\S]*?)(?:;(?:\s*$|\s*[^\s])|\s*$|\s*(?:\*\*|\#\#|--(?!\s*ON)|```|\[\[|\]\]|Query executed|Result:|Error:|Final answer|Step \d+|\d+\.\s))/i);
            if (sqlMatch) {
                sql = sqlMatch[1].trim();
            } else {
                // Fallback: try to capture everything from SELECT to a natural stopping point
                const lastResortMatch = input.match(/(SELECT\s+[\s\S]*?FROM[\s\S]*?)(?:;(?:\s*$|\s*[^\s])|\s*$|\s*(?:\*\*|\#\#|Query executed|Result:|Error:|Final answer))/i);
                if (lastResortMatch) {
                    sql = lastResortMatch[1].trim();
                }
            }
        }
    }

    if (!sql) return '';

    // CRITICAL: Fix malformed SQL structures that SQL Agent generates
    sql = fixMalformedSQLStructures(sql);

    // Clean up markdown and formatting but preserve SQL structure
    sql = sql.replace(/\*\*(.*?)\*\*/g, '$1') // Bold
        .replace(/\*(.*?)\*/g, '$1')          // Italic
        .replace(/__(.*?)__/g, '$1')          // Bold
        // .replace(/_(.*?)_/g, '$1')         // <--- Removed to keep underscores
        .replace(/~~(.*?)~~/g, '$1')          // Strikethrough
        .replace(/\[(.*?)\]\(.*?\)/g, '$1')   // Links
        .replace(/\[\[(.*?)\]\]/g, '$1')      // Wiki links
        .replace(/\s*```[\s\S]*?```\s*/g, ' ') // Other code blocks
        .replace(/`([^`]*)`/g, '$1')          // Inline code
        // .replace(/#+\s+(.*?)\s*(?:\n|$)/g, ' ') // Headings -- REMOVED
        // .replace(/(?:\n|^)\s*-\s+(.*?)(?:\n|$)/g, ' $1 ') // List items -- REMOVED
        // .replace(/(?:\n|^)\s*\d+\.\s+(.*?)(?:\n|$)/g, ' $1 ') // Numbered list items -- REMOVED
        .replace(/--.*?(?:\n|$)/g, ' ')          // SQL comments (but not ON conditions)
        .replace(/\/\/.*?(?:\n|$)/g, ' ')        // JS comments
        .replace(/\/\*[\s\S]*?\*\//g, ' ')       // Multi-line comments
        .replace(/\s*\*\*Review for common mistakes:\*\*[\s\S]*/i, '')
        .replace(/\s*\*\*Notes:\*\*[\s\S]*/i, '')
        .replace(/\{\{.*?\}\}/g, ' ')            // Template tags
        .replace(/\{\%.*?\%\}/g, ' ');           // Template tags

    // Normalize whitespace but preserve SQL structure
    sql = sql.replace(/\s+/g, ' ').trim();

    // Add semicolon if not present
    if (!sql.endsWith(';')) {
        sql += ';';
    }

    return sql;
}

export function isCompleteSQLQuery(sql: string): boolean {
    if (!sql || typeof sql !== 'string') return false;

    // A complete SQL query should have SELECT, FROM, and a valid table reference
    const hasSelect = /\bSELECT\b/i.test(sql);
    const hasFrom = /\bFROM\b/i.test(sql);
    const hasTable = /\bFROM\s+([a-zA-Z0-9_\.]+)/i.test(sql);

    return hasSelect && hasFrom && hasTable;
}

export function fixIncompleteSQLQuery(sql: string): string {
    if (!sql || typeof sql !== 'string') return sql;

    // Already complete
    if (isCompleteSQLQuery(sql)) return sql;

    let fixedSQL = sql;

    // Check if query ends with FROM without a table
    if (/\bFROM\s*(?:;|\s*$)/i.test(sql)) {
        // Extract column names to determine tables
        const columnsMatch = sql.match(/\bSELECT\s+(.*?)\s+FROM\b/i);

        if (columnsMatch) {
            const columns = columnsMatch[1];

            if (columns.includes('p.') && columns.includes('m.')) {
                fixedSQL = sql.replace(/FROM\s*(?:;|\s*$)/i, 'FROM patients p JOIN medications m ON p.id = m.patient_id');
            } else if (columns.includes('p.')) {
                fixedSQL = sql.replace(/FROM\s*(?:;|\s*$)/i, 'FROM patients p');
            } else if (columns.includes('m.')) {
                fixedSQL = sql.replace(/FROM\s*(?:;|\s*$)/i, 'FROM medications m');
            } else if (columns.includes('d.') || columns.includes('doctor')) {
                fixedSQL = sql.replace(/FROM\s*(?:;|\s*$)/i, 'FROM doctors d');
            } else if (columns.includes('v.') || columns.includes('visit')) {
                fixedSQL = sql.replace(/FROM\s*(?:;|\s*$)/i, 'FROM visits v');
            } else {
                // Default to patients table if we can't determine
                fixedSQL = sql.replace(/FROM\s*(?:;|\s*$)/i, 'FROM patients');
            }
        }
    }

    // No SELECT statement found
    if (!fixedSQL.toLowerCase().includes('select')) {
        const possibleSelectMatch = fixedSQL.match(/^[^a-zA-Z]*(.*)/);
        if (possibleSelectMatch && possibleSelectMatch[1].toLowerCase().includes('from')) {
            fixedSQL = 'SELECT * ' + possibleSelectMatch[1];
        } else {
            fixedSQL = 'SELECT * FROM patients';
        }
    }

    // No FROM clause found
    if (!fixedSQL.toLowerCase().includes('from')) {
        fixedSQL += ' FROM patients';
    }

    // If the query doesn't have a semicolon at the end, add one
    if (!fixedSQL.endsWith(';')) {
        fixedSQL += ';';
    }

    return fixedSQL;
}

/**
 * Validates MySQL GROUP BY compliance for only_full_group_by mode
 * @param sql SQL query to validate
 * @returns Object with compliance status and suggested fixes
 */
export function validateMySQLGroupByCompliance(sql: string): {
    isCompliant: boolean;
    issues: string[];
    suggestedFix?: string;
} {
    if (!sql || typeof sql !== 'string') {
        return { isCompliant: true, issues: [] };
    }

    const issues: string[] = [];
    let suggestedFix = '';

    // Parse the SQL to check for GROUP BY compliance
    const sqlUpper = sql.toUpperCase();
    const sqlLower = sql.toLowerCase();

    // Check if the query has aggregation functions
    const aggregationFunctions = ['COUNT(', 'SUM(', 'AVG(', 'MAX(', 'MIN(', 'GROUP_CONCAT('];
    const hasAggregation = aggregationFunctions.some(func => sqlUpper.includes(func.toUpperCase()));

    // Check if the query has GROUP BY
    const hasGroupBy = sqlUpper.includes('GROUP BY');

    if (!hasAggregation) {
        // No aggregation functions, so GROUP BY compliance is not required
        return { isCompliant: true, issues: [] };
    }

    if (!hasGroupBy) {
        issues.push('Query uses aggregation functions but missing GROUP BY clause');

        // Try to suggest a fix by adding GROUP BY for non-aggregated columns
        const selectMatch = sql.match(/SELECT\s+(.*?)\s+FROM/i);
        if (selectMatch) {
            const selectClause = selectMatch[1];
            const columns = selectClause.split(',').map(col => col.trim());

            const nonAggregatedColumns: string[] = [];
            columns.forEach(col => {
                const isAggregated = aggregationFunctions.some(func =>
                    col.toUpperCase().includes(func.toUpperCase())
                );
                if (!isAggregated && !col.includes('*')) {
                    // Extract just the column name, removing aliases
                    const colName = col.replace(/\s+AS\s+\w+/i, '').trim();
                    nonAggregatedColumns.push(colName);
                }
            });

            if (nonAggregatedColumns.length > 0) {
                const fromMatch = sql.match(/FROM[\s\S]*?(?=WHERE|GROUP BY|HAVING|ORDER BY|LIMIT|$)/i);
                const whereMatch = sql.match(/(WHERE[\s\S]*?)(?=GROUP BY|HAVING|ORDER BY|LIMIT|$)/i);
                const havingMatch = sql.match(/(HAVING[\s\S]*?)(?=ORDER BY|LIMIT|$)/i);
                const orderByMatch = sql.match(/(ORDER BY[\s\S]*?)(?=LIMIT|$)/i);
                const limitMatch = sql.match(/(LIMIT[\s\S]*)$/i);

                suggestedFix = `SELECT ${selectClause} ${fromMatch ? fromMatch[0] : ''}`;
                if (whereMatch) suggestedFix += ` ${whereMatch[1]}`;
                suggestedFix += ` GROUP BY ${nonAggregatedColumns.join(', ')}`;
                if (havingMatch) suggestedFix += ` ${havingMatch[1]}`;
                if (orderByMatch) suggestedFix += ` ${orderByMatch[1]}`;
                if (limitMatch) suggestedFix += ` ${limitMatch[1]}`;

                if (!suggestedFix.endsWith(';')) suggestedFix += ';';
            }
        }

        return { isCompliant: false, issues, suggestedFix };
    }

    // Parse SELECT clause to find all columns
    const selectMatch = sql.match(/SELECT\s+(.*?)\s+FROM/i);
    if (!selectMatch) {
        return { isCompliant: true, issues: [] }; // Can't parse, assume compliant
    }

    const selectClause = selectMatch[1];
    const columns = selectClause.split(',').map(col => col.trim());

    // Parse GROUP BY clause
    const groupByMatch = sql.match(/GROUP BY\s+(.*?)(?:\s+HAVING|\s+ORDER BY|\s+LIMIT|;|$)/i);
    if (!groupByMatch) {
        issues.push('GROUP BY clause could not be parsed');
        return { isCompliant: false, issues };
    }

    const groupByClause = groupByMatch[1];
    const groupByColumns = groupByClause.split(',').map(col => col.trim());

    // Check each SELECT column
    const nonAggregatedColumns: string[] = [];
    const missingFromGroupBy: string[] = [];

    columns.forEach(col => {
        const isAggregated = aggregationFunctions.some(func =>
            col.toUpperCase().includes(func.toUpperCase())
        );

        if (!isAggregated && !col.includes('*')) {
            // Extract just the column name, removing aliases and table prefixes for comparison
            let colName = col.replace(/\s+AS\s+\w+/i, '').trim();

            // Check if this column is in GROUP BY
            const isInGroupBy = groupByColumns.some(groupCol => {
                // Normalize both for comparison (remove table prefixes, spaces)
                const normalizedGroupCol = groupCol.replace(/^\w+\./, '').trim();
                const normalizedColName = colName.replace(/^\w+\./, '').trim();
                return normalizedGroupCol === normalizedColName ||
                    groupCol.trim() === colName ||
                    normalizedGroupCol.toLowerCase() === normalizedColName.toLowerCase();
            });

            nonAggregatedColumns.push(colName);

            if (!isInGroupBy) {
                missingFromGroupBy.push(colName);
            }
        }
    });

    if (missingFromGroupBy.length > 0) {
        issues.push(`Non-aggregated columns not in GROUP BY: ${missingFromGroupBy.join(', ')}`);

        // Suggest fix by adding missing columns to GROUP BY
        const additionalGroupBy = missingFromGroupBy.filter(col =>
            !groupByColumns.some(groupCol =>
                groupCol.toLowerCase().includes(col.toLowerCase()) ||
                col.toLowerCase().includes(groupCol.toLowerCase())
            )
        );

        if (additionalGroupBy.length > 0) {
            const newGroupBy = [...groupByColumns, ...additionalGroupBy].join(', ');
            suggestedFix = sql.replace(/GROUP BY\s+.*?(?=\s+HAVING|\s+ORDER BY|\s+LIMIT|;|$)/i, `GROUP BY ${newGroupBy}`);
        }

        return { isCompliant: false, issues, suggestedFix };
    }

    return { isCompliant: true, issues: [] };
}

export function finalCleanSQL(sql: string): string {
    if (!sql || typeof sql !== 'string') return '';

    // First remove any non-ASCII characters that might cause problems
    let cleanSQL = sql.replace(/[^\x00-\x7F]/g, '');

    // Remove any markdown artifacts or non-SQL content that might remain
    cleanSQL = cleanSQL.replace(/```/g, '')
        .replace(/\*\*/g, '')
        .replace(/--.*?(?:\n|$)/g, ' ')
        .replace(/\/\/.*?(?:\n|$)/g, ' ')
        .replace(/\/\*[\s\S]*?\*\//g, ' ')
        .replace(/\s*Review for common mistakes:[\s\S]*/i, '')
        .replace(/\s*Notes:[\s\S]*/i, '');

    // Remove any other non-SQL content that might follow a semicolon
    const semicolonIndex = cleanSQL.indexOf(';');
    if (semicolonIndex !== -1) {
        cleanSQL = cleanSQL.substring(0, semicolonIndex + 1);
    }

    // Normalize whitespace
    cleanSQL = cleanSQL.replace(/\s+/g, ' ').trim();

    // Make sure it starts with SELECT
    if (!cleanSQL.toUpperCase().startsWith('SELECT')) {
        const selectMatch = cleanSQL.match(/(SELECT[\s\S]+)/i);
        if (selectMatch) {
            cleanSQL = selectMatch[1];
        } else {
            return ''; // Not a valid SQL query
        }
    }

    // Make sure it includes FROM
    if (!cleanSQL.toUpperCase().includes(' FROM ')) {
        return ''; // Not a valid SQL query
    }

    // ENHANCED SQL SYNTAX VALIDATION AND FIXING

    // Fix common syntax issues that cause MySQL errors

    // 1. Fix orphaned closing parentheses at the beginning
    cleanSQL = cleanSQL.replace(/^\s*\)\s*/, '');

    // 2. Fix malformed WITH clauses that don't have proper structure
    cleanSQL = cleanSQL.replace(/^\s*WITH\s*\)\s*/i, '');

    // 3. Fix cases where there's a closing parenthesis before SELECT
    cleanSQL = cleanSQL.replace(/^\s*\)\s*(SELECT)/i, '$1');

    // 4. Fix complex query structure issues first
    // Handle cases where we have ") SELECT" which indicates malformed CTE or subquery
    if (/\)\s+SELECT/i.test(cleanSQL)) {
        console.log('ðŸ”§ Detected malformed CTE/subquery structure, attempting to fix...');

        // Pattern: "...GROUP BY field ) SELECT ..." - this is likely a malformed CTE
        const ctePattern = /(SELECT.*?FROM.*?GROUP BY.*?)\s*\)\s*(SELECT.*)/i;
        const cteMatch = cleanSQL.match(ctePattern);

        if (cteMatch) {
            console.log('ðŸ”§ Converting to proper CTE structure...');
            const innerQuery = cteMatch[1];
            const outerQuery = cteMatch[2];

            // Create a proper CTE structure
            cleanSQL = `WITH therapeutic_counts AS (${innerQuery}) ${outerQuery}`;
            console.log('ðŸ”§ Fixed CTE structure:', cleanSQL);
        } else {
            // If we can't parse it as CTE, try to extract the most complete SELECT statement
            console.log('ðŸ”§ Could not parse as CTE, extracting most complete SELECT...');
            const selectMatches = cleanSQL.match(/(SELECT[\s\S]*?(?:;|$))/gi);
            if (selectMatches && selectMatches.length > 0) {
                // Take the longest SELECT statement (likely most complete)
                const longestSelect = selectMatches.reduce((longest, current) =>
                    current.length > longest.length ? current : longest
                );
                cleanSQL = longestSelect;
                console.log('ðŸ”§ Using longest SELECT statement:', cleanSQL);
            }
        }
    }

    // 5. Fix mismatched parentheses - count and balance them
    const openParens = (cleanSQL.match(/\(/g) || []).length;
    const closeParens = (cleanSQL.match(/\)/g) || []).length;

    if (closeParens > openParens) {
        // Remove extra closing parentheses strategically
        let extraClosing = closeParens - openParens;
        console.log(`ðŸ”§ Removing ${extraClosing} extra closing parentheses...`);

        // First, try to remove orphaned closing parentheses at the beginning
        while (extraClosing > 0 && /^\s*\)/.test(cleanSQL)) {
            cleanSQL = cleanSQL.replace(/^\s*\)/, '');
            extraClosing--;
        }

        // If still have extra, remove them from other strategic positions
        while (extraClosing > 0) {
            // Remove closing parentheses that appear before keywords without matching opening
            if (/\)\s+(SELECT|FROM|WHERE|GROUP|ORDER|HAVING|LIMIT)/i.test(cleanSQL)) {
                cleanSQL = cleanSQL.replace(/\)\s+(SELECT|FROM|WHERE|GROUP|ORDER|HAVING|LIMIT)/i, ' $1');
                extraClosing--;
            } else {
                // Remove the last closing parenthesis
                const lastCloseIndex = cleanSQL.lastIndexOf(')');
                if (lastCloseIndex > -1) {
                    cleanSQL = cleanSQL.substring(0, lastCloseIndex) + cleanSQL.substring(lastCloseIndex + 1);
                    extraClosing--;
                } else {
                    break;
                }
            }
        }
    } else if (openParens > closeParens) {
        // Add missing closing parentheses at the end (before semicolon)
        const missingClosing = openParens - closeParens;
        console.log(`ðŸ”§ Adding ${missingClosing} missing closing parentheses...`);
        if (cleanSQL.endsWith(';')) {
            cleanSQL = cleanSQL.slice(0, -1) + ')'.repeat(missingClosing) + ';';
        } else {
            cleanSQL += ')'.repeat(missingClosing);
        }
    }

    // 6. Fix cases where there are multiple SELECT statements incorrectly formatted
    const selectMatches = cleanSQL.match(/SELECT/gi);
    if (selectMatches && selectMatches.length > 1) {
        // If there are multiple SELECTs, take only the first complete one
        const firstSelectIndex = cleanSQL.toUpperCase().indexOf('SELECT');
        let queryEnd = cleanSQL.length;

        // Find the end of the first SELECT statement
        const secondSelectIndex = cleanSQL.toUpperCase().indexOf('SELECT', firstSelectIndex + 6);
        if (secondSelectIndex > -1) {
            queryEnd = secondSelectIndex;
        }

        cleanSQL = cleanSQL.substring(firstSelectIndex, queryEnd).trim();
    }

    // 7. Fix common MySQL syntax issues

    // Fix incorrect LIMIT syntax
    cleanSQL = cleanSQL.replace(/LIMIT\s+(\d+)\s*,\s*(\d+)/gi, 'LIMIT $2 OFFSET $1');

    // Fix incorrect date formatting
    cleanSQL = cleanSQL.replace(/DATE\s*\(\s*['"]([^'"]+)['"]\s*\)/gi, 'DATE(\'$1\')');

    // Fix table alias issues (missing AS keyword or improper spacing)
    cleanSQL = cleanSQL.replace(/(\w+)\s+(\w+)\s+(ON|WHERE|JOIN|GROUP|ORDER|LIMIT|HAVING)/gi, '$1 AS $2 $3');

    // 8. NEW: Fix specific SELECT clause issues that cause syntax errors

    // Fix missing comma after table.* in SELECT clauses
    // Pattern: SELECT table.* function(...) should be SELECT table.*, function(...)
    cleanSQL = cleanSQL.replace(/SELECT\s+([\w.]+\.\*)\s+([A-Z_]+\s*\()/gi, 'SELECT $1, $2');

    // Fix extra "AS" before table names in FROM clause
    // Pattern: FROM AS table_name should be FROM table_name
    cleanSQL = cleanSQL.replace(/FROM\s+AS\s+/gi, 'FROM ');

    // Fix missing comma between SELECT fields - IMPROVED PATTERN
    // Only match field names followed by aggregate functions, not function parameters
    cleanSQL = cleanSQL.replace(/(\w+(?:\.\w+)?)\s+(GROUP_CONCAT|COUNT|SUM|AVG|MAX|MIN)\s*\(/gi, '$1, $2(');

    // Fix orphaned commas before FROM
    cleanSQL = cleanSQL.replace(/,\s*FROM/gi, ' FROM');

    // 9. Validate basic SQL structure
    const upperSQL = cleanSQL.toUpperCase();

    // Ensure proper SELECT structure
    if (!upperSQL.includes('SELECT') || !upperSQL.includes('FROM')) {
        return '';
    }

    // Check for basic syntax requirements
    const hasValidStructure = /SELECT\s+.*\s+FROM\s+\w+/i.test(cleanSQL);
    if (!hasValidStructure) {
        return '';
    }

    // 10. Final cleanup

    // Remove any trailing commas before FROM, WHERE, etc.
    cleanSQL = cleanSQL.replace(/,\s+(FROM|WHERE|GROUP|ORDER|LIMIT|HAVING)/gi, ' $1');

    // Remove any extra spaces
    cleanSQL = cleanSQL.replace(/\s+/g, ' ').trim();

    // Ensure it ends with a semicolon
    if (!cleanSQL.endsWith(';')) {
        cleanSQL += ';';
    }

    return cleanSQL;
}

// New function to validate SQL syntax before execution
export function validateSQLSyntax(sql: string): { isValid: boolean; errors: string[]; fixedSQL: string } {
    const errors: string[] = [];
    let fixedSQL = sql;

    // Basic syntax checks
    const upperSQL = sql.toUpperCase();

    // Check for required elements
    if (!upperSQL.includes('SELECT')) {
        errors.push('Missing SELECT clause');
    }

    if (!upperSQL.includes('FROM')) {
        errors.push('Missing FROM clause');
    }

    // Check for complex query structure issues FIRST
    if (/\)\s+SELECT/i.test(sql)) {
        errors.push('Malformed CTE or subquery structure detected');
        console.log('ðŸ”§ Validator: Detected ") SELECT" pattern, attempting to fix...');

        // Pattern: "...GROUP BY field ) SELECT ..." - this is likely a malformed CTE
        const ctePattern = /(SELECT.*?FROM.*?GROUP BY.*?)\s*\)\s*(SELECT.*)/i;
        const cteMatch = fixedSQL.match(ctePattern);

        if (cteMatch) {
            console.log('ðŸ”§ Validator: Converting to proper CTE structure...');
            const innerQuery = cteMatch[1];
            const outerQuery = cteMatch[2];

            // Create a proper CTE structure
            fixedSQL = `WITH therapeutic_counts AS (${innerQuery}) ${outerQuery}`;
            console.log('ðŸ”§ Validator: Fixed CTE structure:', fixedSQL);
        } else {
            // If we can't parse it as CTE, try to extract the most complete SELECT statement
            console.log('ðŸ”§ Validator: Could not parse as CTE, extracting most complete SELECT...');
            const selectMatches = fixedSQL.match(/(SELECT[\s\S]*?(?:;|$))/gi);
            if (selectMatches && selectMatches.length > 0) {
                // Take the longest SELECT statement (likely most complete)
                const longestSelect = selectMatches.reduce((longest, current) =>
                    current.length > longest.length ? current : longest
                );
                fixedSQL = longestSelect;
                console.log('ðŸ”§ Validator: Using longest SELECT statement:', fixedSQL);
            }
        }
    }

    // Check for multiple SELECT statements (common SQL Agent issue) - Enhanced
    const multiSelectCount = (fixedSQL.match(/\bSELECT\b/gi) || []).length;
    if (multiSelectCount > 1) {
        errors.push('Multiple SELECT statements detected - using first one');
        console.log(`ðŸ”§ Validator: Found ${multiSelectCount} SELECT statements, extracting first complete one...`);

        // Extract the first complete SELECT statement
        const firstSelectMatch = fixedSQL.match(/(SELECT[\s\S]*?FROM[\s\S]*?)(?=\s+SELECT|\s*$)/i);
        if (firstSelectMatch) {
            fixedSQL = firstSelectMatch[1].trim();
            console.log('ðŸ”§ Validator: Extracted first complete SELECT statement');
        }
    }

    // Remove trailing explanatory text that's not SQL
    const explanatoryTextPattern = /This query returns.*$|All patients in the result set.*$|If you need additional.*$/i;
    if (explanatoryTextPattern.test(fixedSQL)) {
        fixedSQL = fixedSQL.replace(explanatoryTextPattern, '').trim();
        errors.push('Removed explanatory text from SQL');
        console.log('ðŸ”§ Validator: Removed trailing explanatory text');
    }

    // Check for unmatched parentheses
    const openParens = (fixedSQL.match(/\(/g) || []).length;
    const closeParens = (fixedSQL.match(/\)/g) || []).length;

    if (openParens !== closeParens) {
        errors.push(`Unmatched parentheses: ${openParens} opening, ${closeParens} closing`);

        // Try to fix parentheses
        if (closeParens > openParens) {
            let extra = closeParens - openParens;
            console.log(`ðŸ”§ Validator: Removing ${extra} extra closing parentheses...`);

            // Remove orphaned closing parentheses at the beginning first
            while (extra > 0 && /^\s*\)/.test(fixedSQL)) {
                fixedSQL = fixedSQL.replace(/^\s*\)/, '');
                extra--;
            }

            // Remove remaining extra closing parentheses strategically
            let remaining = extra;
            while (remaining > 0) {
                if (/\)\s+(SELECT|FROM|WHERE|GROUP|ORDER|HAVING|LIMIT)/i.test(fixedSQL)) {
                    fixedSQL = fixedSQL.replace(/\)\s+(SELECT|FROM|WHERE|GROUP|ORDER|HAVING|LIMIT)/i, ' $1');
                    remaining--;
                } else {
                    // Remove the last closing parenthesis
                    const lastCloseIndex = fixedSQL.lastIndexOf(')');
                    if (lastCloseIndex > -1) {
                        fixedSQL = fixedSQL.substring(0, lastCloseIndex) + fixedSQL.substring(lastCloseIndex + 1);
                        remaining--;
                    } else {
                        break;
                    }
                }
            }
        } else if (openParens > closeParens) {
            const missing = openParens - closeParens;
            console.log(`ðŸ”§ Validator: Adding ${missing} missing closing parentheses...`);
            if (fixedSQL.endsWith(';')) {
                fixedSQL = fixedSQL.slice(0, -1) + ')'.repeat(missing) + ';';
            } else {
                fixedSQL += ')'.repeat(missing);
            }
        }
    }

    // Check for orphaned closing parenthesis at start
    if (/^\s*\)/.test(sql)) {
        errors.push('Orphaned closing parenthesis at start');
        fixedSQL = fixedSQL.replace(/^\s*\)/, '');
    }

    // Check for missing commas in SELECT clause - CRITICAL FIX for common syntax error
    const selectClausePattern = /SELECT\s+(.*?)\s+FROM/i;
    const selectMatch = fixedSQL.match(selectClausePattern);
    if (selectMatch) {
        const selectClause = selectMatch[1];

        // More specific pattern: field_name followed by aggregate function (not within function parameters)
        // Look for cases like "field_name GROUP_CONCAT(" but not "DISTINCT field_name"
        const missingCommaPattern = /(\w+(?:\.\w+)?)\s+(GROUP_CONCAT|COUNT|SUM|AVG|MAX|MIN)\s*\(/g;

        if (missingCommaPattern.test(selectClause)) {
            console.log('ðŸ”§ Validator: Detected missing comma in SELECT clause');
            errors.push('Missing comma in SELECT clause between fields');

            // Fix by adding commas before aggregate functions (but not inside function parameters)
            let fixedSelectClause = selectClause.replace(
                /(\w+(?:\.\w+)?)\s+(GROUP_CONCAT|COUNT|SUM|AVG|MAX|MIN)\s*\(/g,
                '$1, $2('
            );

            // Fix missing commas before table.field references (but avoid function parameters)
            fixedSelectClause = fixedSelectClause.replace(
                /(\w+(?:\.\w+)?)\s+([A-Za-z_]\w*\.[A-Za-z_]\w*)(?!\s*\))/g,
                '$1, $2'
            );

            // Reconstruct the full query
            fixedSQL = fixedSQL.replace(selectClause, fixedSelectClause);
            console.log('ðŸ”§ Validator: Fixed SELECT clause:', fixedSelectClause);
        }
    }

    // Check for malformed WITH clauses
    if (/WITH\s*\)/i.test(sql)) {
        errors.push('Malformed WITH clause');
        fixedSQL = fixedSQL.replace(/WITH\s*\)/gi, '');
    }

    // Check for multiple SELECT statements that might be malformed
    const selectCount = (upperSQL.match(/SELECT/g) || []).length;
    if (selectCount > 1) {
        errors.push('Multiple SELECT statements detected - using first one');
        const firstSelectIndex = upperSQL.indexOf('SELECT');
        const secondSelectIndex = upperSQL.indexOf('SELECT', firstSelectIndex + 6);
        if (secondSelectIndex > -1) {
            fixedSQL = sql.substring(firstSelectIndex, secondSelectIndex).trim();
            if (!fixedSQL.endsWith(';')) {
                fixedSQL += ';';
            }
        }
    }

    return {
        isValid: errors.length === 0,
        errors,
        fixedSQL
    };
}
