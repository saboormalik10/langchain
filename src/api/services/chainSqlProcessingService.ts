import { Response } from "express";

// SQL cleaning function placeholder
function cleanSQLQuery(sql: string): string {
    // This function should be imported or defined elsewhere in the application
    // Basic cleaning implementation
    return sql.trim().replace(/```sql|```/g, '').trim();
}

export interface ChainSqlProcessingResult {
    agentResult: any;
    capturedSQLQueries: string[];
    cleanedChainSQL: string;
    success: boolean;
}

/**
 * Process chain-generated SQL with cleaning and validation
 * @param chainSQLGenerated Chain-generated SQL if available
 * @param chainMetadata Metadata from chain execution
 * @param debugInfo Debug information object
 * @param capturedSQLQueries Array to capture SQL queries
 * @returns ChainSqlProcessingResult Processing result
 */
export function processChainSql(
    chainSQLGenerated: string,
    chainMetadata: any,
    debugInfo: any,
    capturedSQLQueries: string[]
): ChainSqlProcessingResult {
    if (chainSQLGenerated) {
        console.log('üîó Using SQL generated by chain instead of agent');
        console.log('üîç Raw chain SQL before cleaning:', chainSQLGenerated);

        // For chain-generated SQL, we may not need aggressive cleaning since chains should produce clean SQL
        // Try minimal cleaning first
        let cleanedChainSQL = chainSQLGenerated.trim();

        // Only clean if it contains obvious markdown or formatting
        if (chainSQLGenerated.includes('```') || chainSQLGenerated.includes('**') || chainSQLGenerated.includes('*')) {
            console.log('üßπ Chain SQL contains formatting, applying cleaning...');
            cleanedChainSQL = cleanSQLQuery(chainSQLGenerated);
        } else {
            console.log('‚úÖ Chain SQL appears clean, using directly');
            // Just ensure it ends with semicolon
            if (!cleanedChainSQL.endsWith(';')) {
                cleanedChainSQL += ';';
            }
        }

        console.log('üîß Final cleaned chain SQL:', cleanedChainSQL);

        if (cleanedChainSQL) {
            capturedSQLQueries.push(cleanedChainSQL);
            debugInfo.originalQueries.push(chainSQLGenerated);
            debugInfo.extractionAttempts.push('Chain-generated SQL: ' + cleanedChainSQL);

            // Create a mock agent result for consistency with the rest of the flow
            const agentResult = {
                output: `Chain-generated SQL query: ${cleanedChainSQL}`,
                type: 'chain_generated',
                metadata: chainMetadata
            };

            console.log('‚úÖ Chain-generated SQL prepared for execution');
            
            return {
                agentResult,
                capturedSQLQueries,
                cleanedChainSQL,
                success: true
            };
        } else {
            console.log('‚ùå Failed to clean chain-generated SQL, falling back to agent');
            return {
                agentResult: null,
                capturedSQLQueries,
                cleanedChainSQL: '',
                success: false
            };
        }
    }

    return {
        agentResult: null,
        capturedSQLQueries,
        cleanedChainSQL: '',
        success: false
    };
}
